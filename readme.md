###需求：
1.定时开始  
2.用户最多可购买1个     
3.用户只能有一次有效下单   
4.商品抢购完毕，前台显示秒杀结束   
5.一次活动可能有多个秒杀



###前台：
1.活动开始前显示倒计时，禁止点击   
2.隐藏秒杀活动链接，秒杀开始前n秒（n在一定范围内随机，避免人为制造并发请求）发送请求，返回真实的秒杀链接(作用好像不大)  
3.秒杀开始后，每次请求，返回剩余的商品数量，商品数量<=0;禁止点击，显示秒杀结束  
4.如果是已经进入队列的用户，前端显示排队中(或处理中，秒杀中)    
5.排队中的用户，js自动定时查询排队状态，显示排队结果(秒杀成功或失败))  


###后台：
1.活动上线时，设置标准时间，set到redis中，设置过期时间为活动开始时间，ttl key的结果即为倒计时时间   
2.活动开始前，如果接收到秒杀请求，直接返回“活动未开始”;  
3.活动开始后，seckillId:goodsId添加用户id,添加的用户数为商品的库存数量，如果由于并发超过了也无所谓，给前台返回结果：处理中标识，前台禁止用户再次点击，并定时轮询秒杀状态  ---添加前条件判断：使用库存中间量 incr    
3.1：所有请求到达后，先查询查询Set和hash，如果success hash中有，且订单生成完成，则跳转到订单页面     
3.2:添加userId到set中后，发送mq消息，用于生成订单   
4.set中没有用户id，且库存数量小于0，直接给前台返回秒杀结束,前台禁止用户再次点击    
5.mq消费者监听消息，接收到消息后将userId添加到 hash中,订单生成状态为false，减库存，生成订单后，将hash中订单生成状态该为true    
5.1:这一步需要考虑幂等性，如添加到hash前，查看key是否已存在，如果不存在才操作，这里需要使用分布式锁     
5.2:如果使用的mq是每次消费者只能消费一次，则不需要分布式锁 ---activemq使用点对点模式即可，rabbitmq只要订阅同一个队列自然就只消费一次     
6.下单时间为15分钟，超时，无效   


###后台需要记录哪些信息:
用户的id(userId)   
商品id(goodsId)   
活动id(seckillId) 


###数据结构：
redis key: seckillId:goodsId    
redis value: 数据结构：set ,可以去重、随机移除并返回一个元素 